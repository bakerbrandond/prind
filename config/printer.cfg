# This file contains common pin mappings for the Creality CR5 Pro HT.
# The mainboard is a Creality 3D v2.5.1 (8-bit mainboard with
# ATMega2560). To use this config, the firmware should be compiled for
# the AVR atmega2560.

# For better compatibility with GCodes generated for Marlin, you
# may wish to add the following section, if you have BLTouch:
[gcode_macro G29]
gcode:
#G28
#BED_MESH_CALIBRATE
#SAVE_CONFIG
#G1 X0 Y0 Z5 F4000

[display_status]

[gcode_macro print_start]
description: Inserted by slicer at start of print. Rather than using this macro
  directly you should configure your slicer as instructed in the readme.
  Usage: PRINT_START BED=<temp> EXTRUDER=<temp> [CHAMBER=<temp>]
                     [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [LAYERS=<num>]
                     [NOZZLE_SIZE=<mm>]
gcode:
  {action_respond_info(
    "This file is using an old The PRINT_START format. This print will run "
    "fine, but you should update your slicer config to take advantage of the "
    "phased PRINT_START macros. The slicer documentation is here:\n"
    "https://github.com/jschuh/klipper-macros\x23slicer-configuration"
  )}

  _PRINT_START_PHASE_INIT {rawparams}
  _PRINT_START_PHASE_PREHEAT
  _PRINT_START_PHASE_PROBING
  _PRINT_START_PHASE_EXTRUDER
  _PRINT_START_PHASE_PURGE

[gcode_macro _print_start_phase_init]
description: Inserted by slicer at start of print. Initializes PRINT_START
  phases.
  Usage: See PRINT_START.
gcode:
  CHECK_KM_CONFIG # Need this in case startup errors were missed.
  SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
  _KM_APPLY_PRINT_OFFSET RESET=1
  _PRINT_START_PHASE_CHECK PHASE=none
  {% set km = printer["gcode_macro _km_globals"] %}

  {% if not params.BED %}
    {% set dummy = params.__setitem__('BED', params.BED_TEMP|int) %}
  {% endif %}
  {% if not params.EXTRUDER %}
    {% set dummy = params.__setitem__('EXTRUDER', params.EXTRUDER_TEMP|int) %}
  {% endif %}

  # Stash all the params for use by the other phases.
  PRINT_START_SET PRINT_START_PHASE="init" {% for k in params %}{' %s=\"%s\"' %
    (k,params[k]|replace('\\','\\\\')|replace('\'','\\\'')|replace('\"','\\\"'))
  }{% endfor %}

  # Check and propogate the printable bounds.
  _km_check_and_set_print_bounds

  M107 # Turn off part cooling fan in case it was on.
  CLEAR_PAUSE
  # Kick off the longest preheats in the init.
  M140 S{params.BED}
  {% if params.CHAMBER %}M141 S{params.CHAMBER|int}{% endif %}
  {% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
  # Load a saved mesh if configured.
  {% if km.start_try_saved_surface_mesh and printer.bed_mesh %}
    LOAD_SURFACE_MESH
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="preheat"

[gcode_macro _print_start_phase_preheat]
description: Inserted by slicer at start of print. Handles the bed and chamber
  heating phases and ends when both are stabilized at their target temperatures.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=preheat
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set BED = print.BED|int %}
  {% set EXTRUDER = print.EXTRUDER|int %}
  {% set CHAMBER = print.CHAMBER|default(0)|int %}
  {% set LAYERS = print.LAYERS|default(0)|int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  # The bed started at no more than 0.2C below and 1.0C above the target temp.
  {% set bed_at_target = (BED + 0.4 - printer.heater_bed.temperature) |
                           abs <= 0.6 %}
  PRINT_START_SET BED_AT_TARGET={1 if bed_at_target else 0}
  {% set start_level_bed_at_temp = km.start_level_bed_at_temp and
                                   not printer.bed_mesh.profile_name %}
  {% set actions_at_temp = start_level_bed_at_temp or
                           km.start_quad_gantry_level_at_temp or
                           km.start_z_tilt_adjust_at_temp or
                           (km.start_home_z_at_temp and not bed_at_target) %}
  {% set bed_overshoot = (BED + (km.start_bed_heat_overshoot if
             (BED and not bed_at_target) else 0.0),
           printer.configfile.settings.heater_bed.max_temp ) | min %}

  INIT_LAYER_GCODE LAYERS="{LAYERS}"
  {% if CHAMBER > 0.0 %}
    M141 S{CHAMBER}
  {% endif %}
  # Start bed heating
  M140 S{bed_overshoot}
  {% if actions_at_temp %}
    # If we're going to run a bed level we either have a probing temp specified
    # or we heat the extruder part way to avoid oozing while probing.
    M104 S{km.start_extruder_probing_temp if km.start_extruder_probing_temp > 0
      else (km.start_extruder_preheat_scale * EXTRUDER)|round(0,'ceil')|int}
  {% else %}
    M104 S{EXTRUDER}
  {% endif %}
  # home all axes
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
  G28
  G90
  {% if BED > 0.0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=bed_heating RESET_STACK=1
    # Skip this if the bed was already at target when START_PRINT was called.
    {% if not bed_at_target %}
      PARK
      # Overshoot the target a bit.
      M190 S{bed_overshoot}
      G4 P{km.start_bed_heat_delay / 2}
      M190 R{BED} # Settle down after the overshoot.
      G4 P{km.start_bed_heat_delay / 2}
    {% endif %}
  {% endif %}

  {% if CHAMBER > 0.0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=chamber_heating RESET_STACK=1
    _KM_PARK_IF_NEEDED HEATER="chamber" RANGE=ABOVE
    M191 S{CHAMBER}
  {% endif %}

  {% if BED > 0.0 and bed_at_target%}
    M190 R{BED} # Extra bed stabilization if we skipped it earlier.
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="probing"

[gcode_macro _print_start_phase_probing]
description: Inserted by slicer at start of print. Performs probing (including
  mesh bed level) and other operations that should be run when the bed and
  chamber are stabilized at their target temps.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=probing
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set MESH_MIN = print.MESH_MIN|default(None) %}
  {% set MESH_MAX = print.MESH_MAX|default(None) %}
  # Randomize the placement of the print on the bed.
  {% if km.start_random_placement_max > 0 and print.PRINT_MIN and MESH_MIN %}
    {% set PRINT_MIN = print.PRINT_MIN.split(",")|map('float')|list %}
    {% set PRINT_MAX = print.PRINT_MAX.split(",")|map('float')|list %}
    {% set x_offset = (((km.print_max[0] - km.print_min[0] - PRINT_MAX[0] +
         PRINT_MIN[0] - 2 * km.start_random_placement_padding)|int,
         km.start_random_placement_max * 2)|min, 0)|max %}
    {% set y_offset = (((km.print_max[1] - km.print_min[1] - PRINT_MAX[1] +
         PRINT_MIN[1] - 2 * km.start_random_placement_padding)|int,
         km.start_random_placement_max * 2)|min, 0)|max %}
    {% if x_offset > 0 %}
      {% set x_offset = range(x_offset)|random + km.print_min[0] -
                          PRINT_MIN[0] + km.start_random_placement_padding %}
    {% endif %}
    {% if y_offset > 0 %}
      {% set y_offset = range(y_offset)|random + km.print_min[1] -
                          PRINT_MIN[1] + km.start_random_placement_padding %}
    {% endif %}
    # This MESH_MIN/MESH_MAX gets passed to BED_MESH_CALIBRATE below, but the
    # rest of the macros rely on SET_GCODE_OFFSET performing the adjustment.
    {% set MESH_MIN = MESH_MIN.split(",")|map('float')|list %}
    {% set MESH_MAX = MESH_MAX.split(",")|map('float')|list %}
    {% set MESH_MIN_NEW = (MESH_MIN[0] + x_offset, MESH_MIN[1] + y_offset) %}
    {% set MESH_MAX_NEW = (MESH_MAX[0] + x_offset, MESH_MAX[1] + y_offset) %}
    {action_respond_info(
       "Relocating print origin from (%.3f,%.3f) "|format(*MESH_MIN) +
       "to (%.3f,%.3f)"|format(*MESH_MIN_NEW))}
    {% set MESH_MIN = (MESH_MIN_NEW[0], MESH_MIN_NEW[1])|join(',') %}
    {% set MESH_MAX = (MESH_MAX_NEW[0], MESH_MAX_NEW[1])|join(',') %}
    PRINT_START_SET PRINT_OFFSET={"%d,%d" % (x_offset,y_offset)}
  {% endif %}

  {% set EXTRUDER = print.EXTRUDER|int %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set start_level_bed_at_temp = km.start_level_bed_at_temp and
                                   not printer.bed_mesh.profile_name %}
  {% set start_home_z_at_temp = km.start_home_z_at_temp and
                                not print.BED_AT_TARGET|int %}
  {% set actions_at_temp = start_level_bed_at_temp or
                           km.start_quad_gantry_level_at_temp or
                           km.start_z_tilt_adjust_at_temp or
                           start_home_z_at_temp %}
  {% if actions_at_temp %}
    {% if km.start_extruder_probing_temp > 0 %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
      _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
      M109 R{km.start_extruder_probing_temp}
    {% else %}
      M104 S{EXTRUDER} # set the final extruder target temperature
    {% endif %}
    {% if start_home_z_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
      G28 Z # Re-home only the Z axis now that the bed has stabilized.
    {% endif %}
    {% if km.start_z_tilt_adjust_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=calibrating_z RESET_STACK=1
      Z_TILT_ADJUST
    {% endif %}
    {% if km.start_quad_gantry_level_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=leveling_gantry RESET_STACK=1
      QUAD_GANTRY_LEVEL
    {% endif %}
    {% if start_level_bed_at_temp %}
      _KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing RESET_STACK=1
      _km_mesh_if_needed {% if MESH_MIN %} MESH_MIN={MESH_MIN}{% endif
                       %}{% if MESH_MAX %} MESH_MAX={MESH_MAX}{% endif %}
    {% endif %}
    {% if km.start_extruder_probing_temp > 0 %}
      M104 S{EXTRUDER} # set the final extruder target temperature
    {% endif %}
    G4
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="extruder"

[gcode_macro _print_start_phase_extruder]
description: Inserted by slicer at start of print. Preheats the extruder.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=extruder
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set EXTRUDER = print.EXTRUDER|default(print.EXTRUDER_TEMP)|float %}
  {% set km = printer["gcode_macro _km_globals"] %}

  # Wait for extruder to reach temperature
  {% if EXTRUDER > 0 %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
    _KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=ABOVE
    M109 S{EXTRUDER}
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="purge"

[gcode_macro _print_start_phase_purge]
description: Inserted by slicer at start of print. Generates purge lines.
  Usage: See PRINT_START.
gcode:
  _PRINT_START_PHASE_CHECK PHASE=purge
  # Apply the offset for bed placement randomization.
  _KM_APPLY_PRINT_OFFSET
  # apply Z offset for bed surface (just in case it was reset).
  _APPLY_BED_SURFACE_OFFSET
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set MESH_MIN = print.MESH_MIN|default(None) %}
  {% set MESH_MAX = print.MESH_MAX|default(None) %}
  {% set NOZZLE_SIZE = print.NOZZLE_SIZE|default(print.NOZZLE_SIZE)|
         default(printer.configfile.settings.extruder.nozzle_diameter)|float %}
  {% set km = printer["gcode_macro _km_globals"] %}
  {% if km.start_purge_length > 0.0 and printer.extruder.can_extrude %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=purging RESET_STACK=1
    DRAW_PURGE_LINE WIDTH="{NOZZLE_SIZE * 1.25}" HEIGHT="{NOZZLE_SIZE * 0.625
                    }"{% if MESH_MIN %} PRINT_MIN={MESH_MIN}{% endif
                    %}{% if MESH_MAX %} PRINT_MAX={MESH_MAX}{% endif %}
  {% endif %}
  PRINT_START_SET PRINT_START_PHASE="printing"
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=printing RESET_STACK=1

[gcode_macro _km_park_if_needed]
description: Parks the extruder if the current temperature of the supplied
  heater is not within the specified target range.
  Usage: _KM_PARK_IF_NEEDED HEATER=<heater> RANGE=[<percentage>|ABOVE|BELOW]
gcode:
  # This needs to get called as its own macro to get the current temp evaluated.
  {% set HEATER = params.HEATER if params.HEATER in
                    printer.heaters.available_heaters else
                  ("heater_generic " ~ params.HEATER) %}
  {% set RANGE = (params.RANGE|default(1))|string|upper %}

  {% if printer[HEATER].target %}
    {% if RANGE == "ABOVE" %}
      {% if printer[HEATER].temperature < printer[HEATER].target %}
        PARK
      {% endif %}
    {% elif RANGE == "BELOW" %}
      {% if printer[HEATER].temperature > printer[HEATER].target %}
        PARK
      {% endif %}
    {% elif (printer[HEATER].temperature - printer[HEATER].target)|abs >
             (printer[HEATER].target * RANGE|float * 0.01)|abs %}
      PARK
    {% endif %}
  {% endif %}

[gcode_macro _km_apply_print_offset]
variable_offset: []
gcode:
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% if params.RESET|default(0)|int and offset and
        not printer["gcode_macro _km_save_state"].is_ephemeral%}
    {% set PRINT_OFFSET = [offset.pop(0) * -1, offset.pop() * -1] %}
  {% elif print.PRINT_OFFSET and not offset and
          not printer["gcode_macro _km_save_state"].is_ephemeral %}
    {% set PRINT_OFFSET = print.PRINT_OFFSET.split(",")|map('float')|list %}
    {% set dummy = offset.extend(PRINT_OFFSET) %}
  {% endif %}

  {% if PRINT_OFFSET %}
    _KM_SET_GCODE_OFFSET_BASE {"X_ADJUST=%.2f Y_ADJUST=%.2f"|
                                  format(*PRINT_OFFSET)}
  {% endif %}

[gcode_macro _km_mesh_if_needed]
gcode:
  # TODO: Instead of blindly using the loaded mesh we could probe a few key
  # points on the saved grid. If those probes show that the saved grid is no
  # longer in tolerance we could just run BED_MESH_CALIBRATE_FAST anyway.
  {% if not printer.bed_mesh.profile_name %}
    BED_MESH_CALIBRATE_FAST {rawparams}
  {% endif %}

[gcode_macro print_start_set]
description: Inserted by slicer to set values used by PRINT_START.
  Usage: PRINT_START_SET <VARIABLE>=<value>
variable_print: {}
gcode:
  {%for k in params %}
    {% set dummy = print.__setitem__(k|upper, params[k]) %}
  {% endfor %}

[gcode_macro _print_start_phase_check]
gcode:
  {% set print = printer["gcode_macro print_start_set"].print %}
  {% set PRINT_START_PHASE = print.PRINT_START_PHASE|default("none") %}
  {% if PRINT_START_PHASE != params.PHASE %}
    # Reset the phases manually just to be sure.
    SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
    {% if params.PHASE != 'none' %}
      {% set error = "PRINT_START phase error. Expected '%s' but found '%s'" %
                       (params.PHASE, PRINT_START_PHASE) %}
      # Do the cancel manually if we're not confident it will fire.
      {% if not 'virtual_sdcard' in printer or
            not printer.virtual_sdcard.is_active or 'CANCEL_PRINT' not in
              printer.configfile.settings.virtual_sdcard.on_error_gcode|
                default("")|upper %}
        {action_respond_info(error)}
        CANCEL_PRINT
      {% else %}
        {action_raise_error(error)}
      {% endif %}
    {% else %}
      { action_respond_info("Expected phase '%s' but found '%s'. Resetting."
                             % (params.PHASE, PRINT_START_PHASE)) }
    {% endif %}
  {% endif %}

[gcode_macro print_end]
description: Inserted by slicer at end of print.
  Usage: PRINT_END
gcode:
  _KM_CHECK_IS_PRINTING
  M400
  _PRINT_END_INNER

  {% set km = printer["gcode_macro _km_globals"] %}

  {% if km.start_clear_adjustments_at_end != 0 %}
    RESET_HEATER_SCALING
    RESET_FAN_SCALING
    M220 S100
    M221 S100
  {% endif %}
  _RESET_LAYER_GCODE
  _RESET_VELOCITY_LIMITS
  TURN_OFF_HEATERS
  M107; turn off fan
  {% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
  # Park the toolhead and present the bed
  {% if printer.toolhead.homed_axes|lower == "xyz" %}
    PARK Y="{km.start_end_park_y}"
  {% endif %}
  M84 ; disable steppers
  CLEAR_PAUSE
  SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
  _KM_PRINT_STATUS ACTION=CHANGE STATUS=ready RESET_STACK=1

[gcode_macro _print_end_inner]
variable_cancelled: False
gcode:
  SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set toolhead = printer.toolhead %}
  {% set origin = printer.gcode_move.homing_origin%}
  {% set max_x = km.print_max[0] - origin.x %}
  {% set max_y = km.print_max[1] - origin.y %}
  {% set max_z = toolhead.axis_maximum.z - origin.z %}

  {% if not cancelled %}
    _KM_PRINT_STATUS ACTION=CHANGE STATUS=completing
  {% endif %}

  {% if printer.extruder.can_extrude %}
    # Wipe if we're not cancelling a paused print.
    {% if not printer.pause_resume.is_paused and not cancelled and
          toolhead.homed_axes|lower == "xyz" %}
      {% set x_safe = (max_x - toolhead.position.x, 2.0)|min %}
      {% set y_safe = (max_y - toolhead.position.y, 2.0)|min %}
      {% set z_safe = (max_z - toolhead.position.z, 2.0)|min %}
      G91
      G0 Z{z_safe} E-1.0 F{km.travel_speed_z * 2} ; move nozzle up
      G0 X{x_safe} Y{y_safe} E-1.0 F{km.travel_speed_xy} ; remove stringing
      # Remove the offset now that we're done.
      _KM_APPLY_PRINT_OFFSET RESET=1
    {% endif %}

    # Small retract to prevent ooze
    G92 E0
    G1 E-5.0 F3600
    M400
  {% endif %}

[gcode_macro _km_check_is_printing]
variable_debug_state: False # Disables print state check for debugging.
description: Throws an error if print is not currently in progress.
gcode:
  {% if not debug_state and
        printer.idle_timeout.state|string != "Printing" and
        not (printer.virtual_sdcard|default({})).is_active|default(False) and
        not printer.pause_resume.is_paused %}
    { action_raise_error("No active print.") }
  {% endif %}

[gcode_macro _km_check_and_set_print_bounds]
description: Validates all print bounds and caches their values.
gcode:
  {% set km = printer["gcode_macro _km_globals"] %}
  {% set print = printer["gcode_macro print_start_set"].print %}

  # Check the mesh bounds.
  {% if print.MESH_MIN %}
    {% set MESH_MIN = print.MESH_MIN.split(",")|map('float')|list %}
    {% set MESH_MAX = print.MESH_MAX.split(",")|map('float')|list %}
    {%if MESH_MIN[0] < km.print_min[0] or MESH_MIN[1] < km.print_min[1] %}
      {action_raise_error("MESH_MIN %s is outside the printable bounds" %
                            (MESH_MIN|string, km.print_min|string))}
    {%elif MESH_MAX[0] > km.print_max[0] or MESH_MAX[1] > km.print_max[1] %}
      {action_raise_error("MESH_MAX %s is outside the printable bounds %s" %
                            (MESH_MAX|string, km.print_max|string))}
    {% endif %}
  {% endif %}

  # Find all the model bounds (including any bounds passed in).
  {% set points = [] %}
  {% if print.MODEL_MIN or print.MODEL_MAX %}
    {% set MODEL_MIN = print.MODEL_MIN.split(",")|map('float')|list %}
    {% set MODEL_MAX = print.MODEL_MAX.split(",")|map('float')|list %}
    {% set points = [MODEL_MIN, MODEL_MAX] %}
  {% endif %}
  {% if (printer.exclude_object|default({})).objects %}
    {% set points = printer.exclude_object.objects|selectattr('polygon')|
                      map(attribute='polygon')|sum(start=points) %}
    {% set points_len = points|length %}
    {% if points_len >= 2 %}
      {% set x_coords = (points|map(attribute=0)|sort|list)[0::points_len-1] %}
      {% set y_coords = (points|map(attribute=1)|sort|list)[0::points_len-1] %}
      {% set MODEL_MIN = (x_coords[0],y_coords[0])|map('float')|list %}
      {% set MODEL_MAX = (x_coords[1],y_coords[1])|map('float')|list %}
      PRINT_START_SET MODEL_MIN="{MODEL_MIN|join(',')
                   }" MODEL_MAX="{MODEL_MAX|join(',')}"
    {% endif %}
  {% endif %}

  {% if MODEL_MIN %}
    # Check the model bounds.
    {% if MODEL_MIN[0] < km.print_min[0] or MODEL_MIN[1] < km.print_min[1] %}
      {action_raise_error("MODEL_MIN %s is outside the printable bounds" %
                            (MODEL_MIN|string, km.print_min|string))}
    {% elif MODEL_MAX[0] > km.print_max[0] or MODEL_MAX[1] > km.print_max[1] %}
      {action_raise_error("MODEL_MAX %s is outside the printable bounds %s" %
                            (MODEL_MAX|string, km.print_max|string))}
    {% endif %}
  {% endif %}

  # Set the PRINT_LIMITS
  {% if MESH_MIN and MODEL_MIN %}
    PRINT_START_SET PRINT_MIN="{((MODEL_MIN[0],MESH_MIN[0])|min,
                                 (MODEL_MIN[1],MESH_MIN[1])|min)|join(',')
                  }" PRINT_MAX="{((MODEL_MAX[0],MESH_MAX[0])|max,
                                  (MODEL_MAX[1],MESH_MAX[1])|max)|join(',')}"
  {% else %}
    PRINT_START_SET PRINT_MIN="{km.print_min|join(',')
                 }" PRINT_MAX="{km.print_max|join(',')}"
  {% endif %}
[pause_resume]
recover_velocity: 50

[gcode_macro CASE_LIGHT_ON]
gcode:
    SET_PIN PIN=case_light VALUE=1

[gcode_macro CASE_LIGHT_OFF]
gcode:
    SET_PIN PIN=case_light VALUE=0

[gcode_macro CANCEL_PRINT]
rename_existing: BASE_CANCEL_PRINT
gcode:
    TURN_OFF_HEATERS
    CLEAR_PAUSE
    SDCARD_RESET_FILE
    BASE_CANCEL_PRINT

[virtual_sdcard]
path: /opt/printer_data/gcodes

# See docs/Config_Reference.md for a description of parameters.
# TODO 80 steps/mm
# TODO feedrate = 750 mm/s
[stepper_x]
step_pin: PF0 #ar54
dir_pin: !PF1 #ar55
enable_pin: !PD7 #!ar38
microsteps: 16
rotation_distance: 40 # 16 microsteps * 200 steps/rotation / 80 steps/mm
endstop_pin: ^!PE5 #^ar3
position_min: -15
position_max: 300
position_endstop: -15
homing_speed: 50

# TODO steps = 80 steps/mm
# TODO feedrate = 750 mm/s
[stepper_y]
step_pin: PF6 #ar60
dir_pin: !PF7 #ar61
enable_pin: !PF2 #!ar56
microsteps: 16
rotation_distance: 40 # 16 microsteps * 200 steps/rotation / 80 steps/mm
endstop_pin: ^!PJ1 #^ar14
position_endstop: 0
position_max: 220
homing_speed: 50

# TODO steps = 800 steps/mm
# TODO feedrate = 10 mm/s
[stepper_z]
step_pin: PL3 #ar46
dir_pin: !PL1 #!ar48
enable_pin: !PK0 #!ar62
microsteps: 16
rotation_distance: 4 # 16 microsteps * 200 steps/rotation / 800 steps/mm
position_max: 380
position_min: -10
endstop_pin: probe:z_virtual_endstop

[safe_z_home]
home_xy_position: 140, 110
speed: 80
z_hop: 10
z_hop_speed: 10

# TODO steps = 137.65 steps/mm
# TODO feedrate = 75 mm/s
[extruder]
step_pin: PA4 # ar26
dir_pin: !PA6 # !ar28
enable_pin: !PA2 # !ar24
microsteps: 16
rotation_distance: 23.24736 # 16 microsteps * 200 steps/rotation / 137.65 steps/mm
nozzle_diameter: 0.400
filament_diameter: 1.750
heater_pin: PB4 #ar10
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PK5 #analog13
#control: pid
#pid_kp: 17.647
#pid_ki: 1.079
#pid_kd: 72.131
min_temp: 0
max_temp: 300

[heater_bed]
heater_pin: PH5 #ar8
sensor_type: ATC Semitec 104GT-2
sensor_pin: PK6 #analog14
#control: pid
#pid_kp: 75.501
#pid_ki: 2.542
#pid_kd: 560.598
min_temp: 0
max_temp: 130

[fan]
pin: PH6 #ar9

[mcu]
serial: /dev/ttyUSB0
restart_method: command

# TODO print acceleration = 750 mm/s2
# TODO retract acceleration = 1000 mm/s2
# TODO travel acceleration = 300 mm/s2
# TODO x max accel = 2000 mm/s2
# TODO y max accel = 2000 mm/s2
# TODO z max accel = 100 mm/s2
# TODO e max accel = 75 mm/s2
# TODO filament load/unload len 430 mm
# TODO minimum segment time 20000 us
# TODO E max jerk 5 mm/s
# TODO minimum feedrate for print moves 0 mm/
# TODO minimum feedrate for travel moves 0 mm/
# TODO x max jerk 20 mm/s
# TODO y max jerk 20 mm/s
# TODO z max jerk 0.5 mm/s

[printer]
kinematics: cartesian
max_velocity: 300
max_accel: 2000
max_z_velocity: 5
max_z_accel: 100

#[display]
#lcd_type: st7920
#cs_pin: PH1 #ar16
#sclk_pin: PA1 #ar23
#sid_pin: PH0 #ar17
#encoder_pins: ^PC4, ^PC6 #^ar33, ^ar31
#click_pin: ^!PC2 #^!ar35
# DWIN screen currently unsupported

[bltouch]
sensor_pin: ^PD2 #^ar19
control_pin: PB5 #ar11
set_output_mode: 5V
pin_move_time: 0.4
stow_on_each_sample: False
probe_with_touch_mode: False
x_offset: 37.0
y_offset: 0.0
#z_offset: 2.6 #2.63 #2.40  #4.350
samples: 2
sample_retract_dist: 2
samples_result: average

[bed_mesh]
speed: 50
horizontal_move_z: 6
mesh_min: 47,10
mesh_max: 270,210
probe_count: 7,7
algorithm: bicubic

[filament_switch_sensor fil_runout_sensor]
pause_on_runout: True
switch_pin: !PE4 #ar2

[bed_screws]
screw1: 8,5
screw1_name: front left screw
screw2: 8,210
screw2_name: rear left screw
screw3: 218,210
screw3_name: rear right screw
screw4: 218,5
screw4_name: front right screw

[screws_tilt_adjust]
screw1: 8,5
screw1_name: front left screw
screw2: 8,210
screw2_name: rear left screw
screw3: 218,210
screw3_name: rear right screw
screw4: 218,5
screw4_name: front right screw
speed: 50
horizontal_move_z: 10
screw_thread: CW-M4

[output_pin case_light]
pin: PH4 #ar7
value: 1

#[output_pin other_lights]
#Recv: PIN:  13   Port: B7        LED_PIN                                Input  = 0    TIMER0A   PWM:   128    WGM: 3    COM0A: 3    CS: 3    TCCR0A: 3    TCCR0B: 3    TIMSK0: 3   compare interrupt enabled   overflow interrupt enabled
#Recv:  .                  TIMER1C is also tied to this pin                  TIMER1C   PWM:     0    WGM: 4    COM1C: 0    CS: 2    TCCR1A: 0    TCCR1B: 10    TIMSK1: 2   non-standard PWM mode
#pin: PB7
#value: 1

#[output_pin factory_reset]
#Recv: PIN:  12   Port: B6        SUICIDE_PIN                            Output = 0    TIMER1B   PWM:     0    WGM: 4    COM1B: 0    CS: 2    TCCR1A: 0    TCCR1B: 10    TIMSK1: 2   non-standard PWM mode
#pin: PB6
#value: 0

#[temperature_sensor Board_MCU]
#sensor_type: temperature_mcu
##sensor_type: ATC Semitec 104GT-2
##sensor_type: EPCOS 100K B57560G104F
##Recv: PIN:  69   Port: K7 (A15)  TEMP_1_PIN                             Analog in =  1023
#sensor_pin: PK7 #analog15
#min_temp: 0
#max_temp: 100

#Send: M43
#Recv: PIN:   0   Port: E0        RXD0                                   protected
#Recv: PIN:   1   Port: E1        TXD0                                   protected
#Recv: PIN:   4   Port: G5        SERVO3_PIN                             Input  = 0    TIMER0B   PWM:     0    WGM: 3    COM0B: 3    CS: 3    TCCR0A: 3    TCCR0B: 3    TIMSK0: 3   overflow interrupt enabled
#Recv: PIN:   5   Port: E3        SERVO2_PIN                             Input  = 0    TIMER3A   PWM:  -25536    WGM: 0    COM3A: 0    CS: 2    TCCR3A: 0    TCCR3B: 2    TIMSK3: 2   non-standard PWM mode   compare interrupt enabled
#Recv: PIN:   6   Port: H3        SERVO1_PIN                             Input  = 1    TIMER4A   PWM:     0    WGM: 14    COM4A: 2    CS: 1    TCCR4A: 2    TCCR4B: 25    TIMSK4: 0
#Recv: PIN:  15   Port: J0        <unused/unknown>                       Input  = 1
#Recv: PIN:  16   Port: H1        TXD2                                   Input  = 1
#Recv: .                          EXP1_04_PIN                            Input  = 1
#Recv: PIN:  17   Port: H0        RXD2                                   Input  = 1
#Recv: .                          EXP1_03_PIN                            Input  = 1
#Recv: PIN:  20   Port: D1        <unused/unknown>                       Input  = 0
#Recv: PIN:  21   Port: D0        <unused/unknown>                       Input  = 0
#Recv: PIN:  22   Port: A0        <unused/unknown>                       Input  = 0
#Recv: PIN:  23   Port: A1        EXP1_05_PIN                            Input  = 0
#Recv: PIN:  25   Port: A3        EXP1_06_PIN                            Input  = 0
#Recv: PIN:  27   Port: A5        EXP1_07_PIN                            Input  = 0
#Recv: PIN:  29   Port: A7        EXP1_08_PIN                            Input  = 0
#Recv: PIN:  30   Port: C7        E1_ENABLE_PIN                          Input  = 1
#Recv: PIN:  31   Port: C6        EXP2_03_PIN                            Input  = 0
#Recv: PIN:  32   Port: C5        <unused/unknown>                       Input  = 0
#Recv: PIN:  33   Port: C4        EXP2_05_PIN                            Input  = 1
#Recv: PIN:  34   Port: C3        E1_DIR_PIN                             Input  = 0
#Recv: PIN:  35   Port: C2        EXP1_02_PIN                            Input  = 0
#Recv: PIN:  36   Port: C1        E1_STEP_PIN                            Input  = 0
#Recv: PIN:  37   Port: C0        BEEPER_PIN                             Output = 0
#Recv: .                          EXP1_01_PIN                            Output = 0
#Recv: PIN:  39   Port: G2        <unused/unknown>                       Input  = 0
#Recv: PIN:  40   Port: G1        <unused/unknown>                       Input  = 0
#Recv: PIN:  41   Port: G0        EXP2_08_PIN                            Input  = 1
#Recv: PIN:  42   Port: L7        <unused/unknown>                       Input  = 0
#Recv: PIN:  43   Port: L6        <unused/unknown>                       Input  = 0
#Recv: PIN:  44   Port: L5        E1_CS_PIN                              Input  = 1    TIMER5C   PWM:     0    WGM: 14    COM5C: 0    CS: 1    TCCR5A: 2    TCCR5B: 25    TIMSK5: 0
#Recv: PIN:  45   Port: L4        <unused/unknown>                       Input  = 0                           TIMER5B   PWM:     0    WGM: 14    COM5B: 2    CS: 1    TCCR5A: 2    TCCR5B: 25    TIMSK5: 0
#Recv: PIN:  47   Port: L2        <unused/unknown>                       Input  = 0
#Recv: PIN:  49   Port: L0        EXP2_07_PIN                            Input  = 1
#Recv: .                          SD_DETECT_PIN                          Input  = 1
#Recv: PIN:  50   Port: B3        AVR_MISO_PIN                           Input  = 0
#Recv: .                          EXP2_01_PIN                            Input  = 0
#Recv: .                          SD_MISO_PIN                            Input  = 0
#Recv: PIN:  51   Port: B2        AVR_MOSI_PIN                           Output = 1
#Recv: .                          EXP2_06_PIN                            Output = 1
#Recv: .                          SD_MOSI_PIN                            Output = 1
#Recv: PIN:  52   Port: B1        AVR_SCK_PIN                            Output = 0
#Recv: .                          EXP2_02_PIN                            Output = 0
#Recv: .                          SD_SCK_PIN                             Output = 0
#Recv: PIN:  53   Port: B0        AVR_SS_PIN                             Output = 1
#Recv: .                          EXP2_04_PIN                            Output = 1
#Recv: .                          SDSS                                   Output = 1
#Recv: .                          SD_SS_PIN                              Output = 1
#Recv: PIN:  57   Port: F3 (A 3)  <unused/unknown>   Analog in =   443   Input  = 0
#Recv: PIN:  58   Port: F4 (A 4)  <unused/unknown>   Analog in =   430   Input  = 0
#Recv: PIN:  59   Port: F5 (A 5)  FILWIDTH_PIN                           Analog in =   818
#Recv: PIN:  63   Port: K1 (A 9)  <unused/unknown>   Analog in =   819   Input  = 1
#Recv: PIN:  64   Port: K2 (A10)  <unused/unknown>   Analog in =   691   Input  = 1
#Recv: PIN:  65   Port: K3 (A11)  <unused/unknown>   Analog in =   669   Input  = 1

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [bed_mesh default]
#*# version = 1
#*# points =
#*# 	  -0.020000, 0.016875, 0.037500, 0.030000, 0.043750, 0.064375, 0.066875
#*# 	  -0.057500, -0.005625, -0.013750, 0.005000, 0.031250, 0.048750, 0.038750
#*# 	  -0.103750, -0.060625, -0.043125, -0.000625, 0.010625, 0.026250, 0.040000
#*# 	  -0.102500, -0.074375, -0.040625, -0.028125, 0.036250, 0.036250, 0.040625
#*# 	  -0.089375, -0.054375, -0.041250, -0.026875, 0.003125, 0.025625, 0.019375
#*# 	  -0.091250, -0.060000, -0.013750, -0.015625, 0.008750, -0.002500, 0.015000
#*# 	  -0.023750, -0.017500, -0.031250, -0.042500, -0.009375, -0.006250, -0.011875
#*# tension = 0.2
#*# min_x = 47.0
#*# algo = bicubic
#*# y_count = 7
#*# mesh_y_pps = 2
#*# min_y = 10.0
#*# x_count = 7
#*# max_y = 209.97
#*# mesh_x_pps = 2
#*# max_x = 269.96000000000004
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 74.756
#*# pid_ki = 1.970
#*# pid_kd = 709.247
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 18.504
#*# pid_ki = 1.045
#*# pid_kd = 81.881
#*#
#*# [bltouch]
#*# z_offset = 2.549
